name: Parallel CI/CD Pipeline

on:
  push:
    branches: [main]
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'k8s/**'
      - '.github/workflows/parallel-ci-cd.yml'
  pull_request:
    branches: [main]
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'k8s/**'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
  AKS_RESOURCE_GROUP: ${{ secrets.AKS_RESOURCE_GROUP }}
  AKS_CLUSTER_NAME: ${{ secrets.AKS_CLUSTER_NAME }}

jobs:
  # BACKEND PIPELINE
  backend:
    name: "ðŸ”§ Backend Pipeline"
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
    - name: "ðŸ“¥ Checkout code"
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: "âš™ï¸ Setup Node.js for Backend"
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: backend/package-lock.json
        
    - name: "ðŸ“¦ Install Backend Dependencies"
      run: |
        cd backend
        npm ci
        
    - name: "ðŸ—ï¸ Build Backend"
      run: |
        cd backend
        npm run build || echo "No build script, continuing..."
        
    - name: "ðŸ§ª Run Backend Tests"
      run: |
        cd backend
        npm test || echo "Tests failed but continuing..."
        
    - name: "ðŸ“¦ Upload Backend Artifacts"
      uses: actions/upload-artifact@v4
      with:
        name: backend-build
        path: |
          backend/
          !backend/node_modules/
        retention-days: 1
        
    - name: "ðŸ³ Set up Docker Buildx"
      uses: docker/setup-buildx-action@v3
      
    - name: "ðŸ” Log in to Azure Container Registry"
      uses: azure/docker-login@v1
      with:
        login-server: ${{ secrets.ACR_LOGIN_SERVER }}
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}
        
    - name: "ðŸ“¥ Download Backend Artifacts"
      uses: actions/download-artifact@v4
      with:
        name: backend-build
        path: backend-restored
        
    - name: "ðŸ—ï¸ Build and push Backend Docker image"
      uses: docker/build-push-action@v5
      with:
        context: backend-restored/backend
        push: ${{ github.event_name == 'push' }}
        tags: |
          ${{ secrets.ACR_LOGIN_SERVER }}/todo-backend:${{ github.sha }}
          ${{ secrets.ACR_LOGIN_SERVER }}/todo-backend:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64
        
    - name: "ðŸ” Run Trivy vulnerability scan on Backend"
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: '${{ secrets.ACR_LOGIN_SERVER }}/todo-backend:${{ github.sha }}'
        format: 'sarif'
        output: 'trivy-backend-results.sarif'
        severity: 'HIGH,CRITICAL'
        
    - name: "ðŸ“¤ Upload Trivy scan results"
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-backend-results.sarif'

  # FRONTEND PIPELINE
  frontend:
    name: "ðŸŽ¨ Frontend Pipeline"
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
    - name: "ðŸ“¥ Checkout code"
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: "âš™ï¸ Setup Node.js for Frontend"
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
        
    - name: "ðŸ“¦ Install Frontend Dependencies"
      run: |
        cd frontend
        npm ci
        
    - name: "ðŸ—ï¸ Build Frontend"
      run: |
        cd frontend
        CI=false npm run build
        
    - name: "ðŸ§ª Run Frontend Tests"
      run: |
        cd frontend
        npm test || echo "Tests failed but continuing..."
        
    - name: "ðŸ“¦ Upload Frontend Artifacts"
      uses: actions/upload-artifact@v4
      with:
        name: frontend-build
        path: |
          frontend/
          !frontend/node_modules/
        retention-days: 1
        
    - name: "ðŸ³ Set up Docker Buildx"
      uses: docker/setup-buildx-action@v3
      
    - name: "ðŸ” Log in to Azure Container Registry"
      uses: azure/docker-login@v1
      with:
        login-server: ${{ secrets.ACR_LOGIN_SERVER }}
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}
        
    - name: "ðŸ“¥ Download Frontend Artifacts"
      uses: actions/download-artifact@v4
      with:
        name: frontend-build
        path: frontend-restored
        
    - name: "ðŸ—ï¸ Build and push Frontend Docker image"
      uses: docker/build-push-action@v5
      with:
        context: frontend-restored/frontend
        push: ${{ github.event_name == 'push' }}
        tags: |
          ${{ secrets.ACR_LOGIN_SERVER }}/todo-frontend:${{ github.sha }}
          ${{ secrets.ACR_LOGIN_SERVER }}/todo-frontend:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64
        
    - name: "ðŸ” Run Trivy vulnerability scan on Frontend"
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: '${{ secrets.ACR_LOGIN_SERVER }}/todo-frontend:${{ github.sha }}'
        format: 'sarif'
        output: 'trivy-frontend-results.sarif'
        severity: 'HIGH,CRITICAL'
        
    - name: "ðŸ“¤ Upload Trivy scan results"
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-frontend-results.sarif'

  # DEPLOYMENT - Runs after both backend and frontend complete
  deploy:
    name: "ðŸš€ Deploy to AKS"
    needs: [backend, frontend]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    
    steps:
    - name: "ðŸ“¥ Checkout code"
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: "âš™ï¸ Set up kubectl"
      uses: azure/setup-kubectl@v3
      
    - name: "ðŸ” Login to Azure"
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: "ðŸ“‹ Get AKS credentials"
      run: |
        az aks get-credentials \
          --resource-group ${{ secrets.AKS_RESOURCE_GROUP }} \
          --name ${{ secrets.AKS_CLUSTER_NAME }} \
          --overwrite-existing
          
    - name: "ðŸ“¥ Download Kubernetes Manifests"
      uses: actions/download-artifact@v4
      with:
        name: k8s-manifests
        path: k8s-restored
      continue-on-error: true
        
    - name: "ðŸ—„ï¸ Deploy MongoDB"
      run: |
        echo "Deploying MongoDB..."
        kubectl apply -f k8s/backend/mongodb.yaml
        kubectl rollout status deployment/mongodb --timeout=120s
        
    - name: "ðŸ”µðŸŸ¢ Deploy Backend (Blue-Green)"
      run: |
        echo "Starting Blue-Green deployment for backend..."
        
        # Check current deployment color
        CURRENT_COLOR=$(kubectl get deployment backend-deployment -o jsonpath='{.spec.template.metadata.labels.color}' 2>/dev/null || echo "blue")
        
        if [ "$CURRENT_COLOR" = "blue" ]; then
          NEW_COLOR="green"
        else
          NEW_COLOR="blue"
        fi
        
        echo "Current: $CURRENT_COLOR, New: $NEW_COLOR"
        
        # Create new deployment with new color
        cat k8s/backend/deployment.yaml | \
          sed "s|placeholder/backend:latest|${{ secrets.ACR_LOGIN_SERVER }}/todo-backend:${{ github.sha }}|g" | \
          sed "s|app: backend|app: backend\n        color: $NEW_COLOR|g" | \
          kubectl apply -f -
        
        # Wait for new deployment to be ready
        echo "Waiting for backend deployment to be ready..."
        kubectl rollout status deployment/backend-deployment --timeout=300s
        
        # Update service to point to new color
        kubectl patch service backend-service -p "{\"spec\":{\"selector\":{\"color\":\"$NEW_COLOR\"}}}" || \
          kubectl apply -f k8s/backend/service.yaml
        
        # Scale down old deployment (keep 1 pod for rollback)
        kubectl scale deployment/backend-deployment --replicas=1 --selector=color=$CURRENT_COLOR 2>/dev/null || true
        
        echo "âœ… Backend Blue-Green deployment completed"
        
    - name: "ðŸ”µðŸŸ¢ Deploy Frontend (Blue-Green)"
      run: |
        echo "Starting Blue-Green deployment for frontend..."
        
        # Check current deployment color
        CURRENT_COLOR=$(kubectl get deployment frontend-deployment -o jsonpath='{.spec.template.metadata.labels.color}' 2>/dev/null || echo "blue")
        
        if [ "$CURRENT_COLOR" = "blue" ]; then
          NEW_COLOR="green"
        else
          NEW_COLOR="blue"
        fi
        
        echo "Current: $CURRENT_COLOR, New: $NEW_COLOR"
        
        # Create new deployment with new color
        cat k8s/frontend/deployment.yaml | \
          sed "s|placeholder/frontend:latest|${{ secrets.ACR_LOGIN_SERVER }}/todo-frontend:${{ github.sha }}|g" | \
          sed "s|app: frontend|app: frontend\n        color: $NEW_COLOR|g" | \
          kubectl apply -f -
        
        # Wait for new deployment to be ready
        echo "Waiting for frontend deployment to be ready..."
        kubectl rollout status deployment/frontend-deployment --timeout=300s
        
        # Apply LoadBalancer service
        kubectl apply -f k8s/frontend/service.yaml
        
        # Scale down old deployment (keep 1 pod for rollback)
        kubectl scale deployment/frontend-deployment --replicas=1 --selector=color=$CURRENT_COLOR 2>/dev/null || true
        
        echo "âœ… Frontend Blue-Green deployment completed"
        
    - name: "â³ Wait for LoadBalancer IP"
      run: |
        echo "Waiting for LoadBalancer IP assignment..."
        sleep 30
        
        # Wait up to 2 minutes for IP
        for i in {1..12}; do
          EXTERNAL_IP=$(kubectl get service frontend-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
          if [ ! -z "$EXTERNAL_IP" ] && [ "$EXTERNAL_IP" != "null" ]; then
            echo "âœ… LoadBalancer IP: $EXTERNAL_IP"
            echo "FRONTEND_URL=http://$EXTERNAL_IP" >> $GITHUB_ENV
            echo "BACKEND_API=http://$EXTERNAL_IP/api/health" >> $GITHUB_ENV
            break
          fi
          echo "Waiting for IP... ($i/12)"
          sleep 10
        done
        
        if [ -z "$EXTERNAL_IP" ]; then
          echo "âš ï¸ LoadBalancer IP not assigned yet. It may take a few more minutes."
          echo "Check with: kubectl get service frontend-service -w"
        fi
        
    - name: "ðŸ©º Health Check"
      run: |
        if [ ! -z "$FRONTEND_URL" ]; then
          echo "Testing application health..."
          
          # Test frontend
          echo "Frontend: $FRONTEND_URL"
          curl -s -o /dev/null -w "Frontend HTTP Status: %{http_code}\n" $FRONTEND_URL || echo "Frontend not reachable"
          
          # Test backend API
          echo "Backend API: $BACKEND_API"
          curl -s -o /dev/null -w "Backend HTTP Status: %{http_code}\n" $BACKEND_API || echo "Backend API not reachable"
          
          # Get full backend response
          curl -s $BACKEND_API | jq . 2>/dev/null || curl -s $BACKEND_API
        else
          echo "Skipping health check - LoadBalancer IP not available"
        fi
        
    - name: "ðŸ“Š Deployment Status"
      run: |
        echo "=== Deployment Status ==="
        kubectl get deployments
        echo ""
        echo "=== Pods ==="
        kubectl get pods
        echo ""
        echo "=== Services ==="
        kubectl get services
        echo ""
        echo "=== Events (last 5) ==="
        kubectl get events --sort-by='.lastTimestamp' | tail -5
        
    - name: "ðŸ“ Deployment Summary"
      if: always()
      run: |
        echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Timestamp:** $(date)" >> $GITHUB_STEP_SUMMARY
        echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### âœ… Backend" >> $GITHUB_STEP_SUMMARY
        echo "- Image: ${{ secrets.ACR_LOGIN_SERVER }}/todo-backend:${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- Status: $(kubectl get deployment backend-deployment -o jsonpath='{.status.conditions[?(@.type=="Available")].status}' 2>/dev/null || echo 'Unknown')" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### âœ… Frontend" >> $GITHUB_STEP_SUMMARY
        echo "- Image: ${{ secrets.ACR_LOGIN_SERVER }}/todo-frontend:${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- Status: $(kubectl get deployment frontend-deployment -o jsonpath='{.status.conditions[?(@.type=="Available")].status}' 2>/dev/null || echo 'Unknown')" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        if [ ! -z "$FRONTEND_URL" ]; then
          echo "### ðŸŒ Access URLs" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend:** [$FRONTEND_URL]($FRONTEND_URL)" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend API:** [$BACKEND_API]($BACKEND_API)" >> $GITHUB_STEP_SUMMARY
        fi
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“Š Resources" >> $GITHUB_STEP_SUMMARY
        echo '```bash' >> $GITHUB_STEP_SUMMARY
        kubectl get pods 2>/dev/null >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY

  # ARTIFACT STORAGE (Optional - stores build artifacts)
  store-artifacts:
    name: "ðŸ’¾ Store Build Artifacts"
    needs: [backend, frontend]
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
    - name: "ðŸ“¥ Download All Artifacts"
      uses: actions/download-artifact@v4
      with:
        path: artifacts
        
    - name: "ðŸ“¦ Upload Combined Artifacts"
      uses: actions/upload-artifact@v4
      with:
        name: ci-cd-artifacts-${{ github.sha }}
        path: artifacts/
        retention-days: 30
        
    - name: "ðŸ“Š Artifact Summary"
      run: |
        echo "=== Artifact Summary ==="
        find artifacts -type f | head -20
        echo ""
        echo "Total files: $(find artifacts -type f | wc -l)"
        echo "Total size: $(du -sh artifacts | cut -f1)"